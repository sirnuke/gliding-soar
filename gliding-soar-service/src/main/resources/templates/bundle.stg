import "common.stg"

bundle(model, root, standalone, arguments, version, when) ::= <<
<header(version, when, arguments)>

<root.children:childNamespace()>
<root.elements; separator="\n">

<if(standalone)>
<topProcs()>
<namespace("glide", glideProcs())>
<endif>
>>

header(version, when, arguments) ::= <<
# Glide v<version>
# Generated on <when>
#
<if(arguments)># Arguments: <arguments; separator=" "><endif>
#
# Autogenerated code, do not modify
>>

// NOTE: public=false because otherwise it would try to export the procs, which aren't in a namespace
topProcs() ::= <<
# Generates a checked elaboration rule
#
# Enforces that the RHS does not propose an operator.  Prepends the production
# name with the scope variable, if set, plus elaborate.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="elaboration", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

# Generates a checked proposal rule
#
# Enforces that the RHS proposes an operator, but otherwise does not modify
# working memory.  Prepends the production name with the scope variable, if set, plus
# propose.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="proposal", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>


# Generates a checked monitor rule
#
# Enforces that the RHS neither proposes an operator, nor directly modify
# working memory.  Allows RHS functions, since they typically do not modify
# the agent, though that cannot be checked.  Prepends the production name
# with the scope variable, if set, plus monitor.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="monitor", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

# Creates an unchecked production
#
# Enforces typing, but otherwise does not enforce any rules.  Go hog wild.
# Prepends the production name with scope variable, if set, but no other keywords.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="production", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

>>

glideProcs() ::= <<
# Sets the local SCOPE variable
#
# All Glide productions, plus logging, between set-scope calls will be labeled
# as belonging to this common scope.  A typical, but not required, strategy
# would be to use the relative path and filename of the current file.
#
# Yes, ideally this would be set automagically, but JTCL is awful and doesn't
# support [info frame], so scripts can't progmatically determine where they are.
# Call your congressional representatives and complain.
#
# keywords  List of tokens to combine into the scope
<proc(name=funcSetScope(), args="keywords", public=true, body={<\\>
variable <scopeVariable()> [join $keywords *]<\\>
})>

<proc(name=funcCreate(), args="type destination attribute binding attrs", public=true, body={<\\>
<checkRhsElaboration()>
<checkTypes("$attrs")>
<checkTypes(list([
    list(["type", "$type", "Type"]),
    list(["destination", "$destination", "Binding"]),
    list(["attribute", "$attribute", "String"]),
    list(["binding", "$binding", "Binding"])
]))>
<claimBinding("$binding", "$type")>
<checkIModification("$destination", "$attribute", "$type")>
<set(var="attrs_", value_={[<funcConvertAttrs()> $attrs]})>
<return(ngsCreateTypedObject("$destination", "$attribute", "$type", "$binding", "$attrs_"))><\\>
})>

<proc(name=funcCreateByOperator(), args="type destination attribute binding state action add_prefs attrs", public=true, body={<\\>
<checkRhsProposal()>
<checkTypes("$attrs")>
<checkTypes(list([
    list(["type", "$Type", "Type"]),
    list(["destination", "$destination", "Binding"]),
    list(["attribute", "$attribute", "Attribute"]),
    list(["binding", "$binding", "Binding"]),
    list(["state", "$state", "State"]),
    list(["add_prefs", "$add_prefs", "Preferences"])
]))>

<claimBinding("$binding", "$type")>
<checkOModification("$destination", "$attribute", "$type")>
<set(var="attrs_", value_={[<funcConvertAttrs()> $attrs]})>
<return(ngsCreateTypedObjectByOperator("$state", "$destination", "$attribute", "$type", "$binding", "$attrs_", "$action", "$add_prefs"))><\\>
})>

<proc(name=funcBindTo(), args="type target_binding attribute block", public=true, body={<\\>
<checkLhs()>
# TODO: Stub!<\\>
})>

<proc(name=funcTest(), args="type binding tests", public=true, body={<\\>
<checkLhs()>
# TODO: Stub!<\\>
})>

<proc(name=funcCheckLhs(), args="type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcCheckRhs(), args="type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcCheckTypes(), args="spec", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcClaimBinding(), args="binding type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcCheckIMod(), args="binding attribute type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcCheckOMod(), args="binding attribute type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name=funcStateBinding(), args="", public=true, body={<\\>
# TODO: Stub!
<return(binding("state"))><\\>
})>

<proc(name=funcInputBinding(), args="", public=true, body={<\\>
# TODO: Stub!
<return(binding("input-link"))><\\>
})>

<proc(name=funcOutputBinding(), args="", public=true, body={<\\>
# TODO: Stub!
<return(binding("output-link"))><\\>
})>

<proc(name=funcConvertAttrs(), args="attrs", public=false, body={<\\>
<set("result", {""})>
<foreach("attr", "$attrs", {<\\>
    lappend result [lindex $attr 0] [lindex $attr 1]<\\>
})>
<return("$result")><\\>
})>
>>

childNamespace(ns) ::= <<
<namespace(ns.name, {
<ns.children:childNamespace()>
<ns.elements; separator="\n">
})>
>>
