import "common.stg"

bundle(model, root, arguments, version, when) ::= <<
<header(version, when, arguments)>

<root.children:childNamespace()>
<root.elements; separator="\n">

<topProcs()>
<namespace("glide", glideProcs())>
>>

header(version, when, arguments) ::= <<
# Glide v<version>
# Generated on <when>
#
<if(arguments)># Arguments: <arguments; separator=" "><endif>
#
# Autogenerated code, do not modify
>>

// NOTE: public=false because otherwise it would try to export the procs, which aren't in a namespace
topProcs() ::= <<
# Generates a checked elaboration rule
#
# Enforces that the RHS does not propose an operator.  Prepends the production
# name with $SCOPE, if set, plus elaborate.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="elaboration", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

# Generates a checked proposal rule
#
# Enforces that the RHS proposes an operator, but otherwise does not modify
# working memory.  Prepends the production name with $SCOPE, if set, plus
# propose.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="proposal", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>


# Generates a checked monitor rule
#
# Enforces that the RHS neither proposes an operator, nor directly modify
# working memory.  Allows RHS functions, since they typically do not modify
# the agent, though that cannot be checked.  Prepends the production name
# with $SCOPE, if set, plus monitor.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="monitor", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

# Creates an unchecked production
#
# Enforces typing, but otherwise does not enforce any rules.  Go hog wild.
# Prepends the production name with $SCOPE, if set, but no other keywords.
#
# name          The production name
# docstring?    Production's docstring, optional
# lhs           LHS string block
# -->           Ignored, style word to make rules more readable
# rhs           RHS string block
<proc(name="production", args="args", public=false, body={<\\>
# TODO: Stub!<\\>
})>

# Sets the local SCOPE variable
#
# All Glide productions, plus logging, between set-scope calls will be labeled
# as belonging to this common scope.  A typical, but not required, strategy
# would be to use the relative path and filename of the current file.
#
# Yes, ideally this would be set automagically, but JTCL is awful and doesn't
# support [info frame], so scripts can progmatically determine where they are.
# Call your congress representative and complain.
#
#
<proc(name="set-scope", args="keywords", public=false, body={<\\>
variable <getScopeVariable()> [join $keywords *]<\\>
})>

>>

glideProcs() ::= <<
<proc(name="check-rhs", args="type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name="check-types", args="spec", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name="claim-binding", args="binding type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name="check-i-modification", args="binding attribute type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name="check-o-modification", args="binding attribute type", public=true, body={<\\>
# TODO: Stub!<\\>
})>

<proc(name="state-binding", args="", public=true, body={<\\>
# TODO: Stub!
return "\<s>"<\\>
})>

>>

childNamespace(ns) ::= <<
<namespace(ns.name, {
<ns.children:childNamespace()>
<ns.elements; separator="\n">
})>
>>
