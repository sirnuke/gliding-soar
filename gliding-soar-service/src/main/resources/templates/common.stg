/*
 * Generic AST->Text templates
 */

requiredParametersAsArguments(members) ::= <<
<members:{m|<if(m.param&&!m.optional)><\\>
<m.identifier.lowercase> <\\>
<endif><\\>
}>
>>

optionalParametersAsArguments(members) ::= <<
<members:{m|<if(m.param&&m.optional)><\\>
<optionalArguments(m.identifier.lowercase)> <\\>
<endif><\\>
}>
>>

memberDefinitionVariable() ::= "members"

funcSetScope() ::= "set-scope"
funcCheckRhs() ::= "_check-rhs"
funcCheckTypes() ::= "_check-types"
funcClaimBinding() ::= "_claim-binding"
funcOutputBinding() ::= "output-binding"
funcInputBinding() ::= "input-binding"
funcStateBinding() ::= "state-binding"
funcGoalBinding() ::= "goal-binding"
funcCheckIMod() ::= "_check-i-modification"
funcCheckOMod() ::= "_check-o-modification"
funcCreate() ::= "_create"
funcCreateByOperator() ::= "_create_by_operator"
funcConvertAttrs() ::= "_convert_attrs"

checkRhsElaboration() ::= "<funcCheckRhs()> elaboration"
checkRhsProposal()    ::= "<funcCheckRhs()> proposal"

defineMembers(element) ::= <<
<variable(memberDefinitionVariable(), dictCreate(element.allMembers:defineMember()))>
>>

defineMember(member) ::= <<
<member.identifier> <dictCreate({<\\>
support <member.support.label> <\\>
param <member.param> <\\>
optional <member.optional> <\\>
const <member.const> <\\>
tag <member.tag> <\\>
type <member.type> <\\>
multiple <member.multiple><\\>
})>
>>


checkTypes(list) ::= <<
<funcCheckTypes()> <list; separator=" ">
>>
claimBinding(val, type) ::= "<funcClaimBinding()> <val> <type>"

callCreate(type, destination, attribute, binding, attrs) ::= "[::glide::<funcCreate()> <type> <destination> <attribute> <binding> <attrs>]"
callCreateByOperator(type, destination, attribute, binding, state, add_prefs, attrs) ::= "[::glide::<funcCreateByOperator()> <type> <destination> <attribute> <binding> <state> <add_prefs> <attrs>]"

checkIModification(destination, attribute, type) ::= "<funcCheckIMod()> <destination> <attribute> <type>"
checkOModification(destination, attribute, type) ::= "<funcCheckOMod()> <destination> <attribute> <type>"

inputBinding() ::= "[::glide::<funcInputBinding()>]"
outputBinding() ::= "[::glide::<funcOutputBinding()>]"
stateBinding() ::= "[::glide::<funcStateBinding()>]"
goalBinding() ::= "[::glide::<funcGoalBinding()>]"

setDefaultValue(varName, defaultValue) ::= <<
<ifElse({$<varName> eq ""},
{set <varName>_ <defaultValue>},
{set <varName>_ $<varName>}
)>
>>

createAttrsOfAllParameters(var, members) ::= <<
<set(var, list({<members:createAttrFromMember(); separator=" ">}))>
>>

createAttrFromMember(member) ::= <<
<if(member.param)><\\>
[list <member.identifier.value> <toSafeVar(member.identifier.value)> <member.type.value>]<\\>
<endif>
>>

scopeVariable() ::= "::glide::_scope"

/*
 * Pure generic Soar templates
 */

binding(identifier) ::= "\<<identifier>>"

/*
 * NGS Wrappers
 */

// TODO: This assumes that we'll never want NGS to create any defaults for us (probably safe?)
ngsDeclareType(type) ::= "::NGS_DeclareType <type> {}"
ngsCreateAttribute(binding, attribute, val) ::= "[ngs-create-attribute <binding> <attribute> <val>]"
ngsCreateTypedObject(destination, attribute, type, binding, attrs) ::= "[ngs-create-typed-object <destination> <attribute> <type> <binding> <attrs>]"
ngsCreateTypedObjectByOperator(state, destination, attribute, type, binding, attrs, action, prefs) ::= "[ngs-create-typed-object-by-operator <state> <destination> <attribute> <type> <binding> <attrs> <action> <prefs>]"
ngsDeepCopy(state, destination, attribute, binding, action, prefs) ::= "[ngs-deep-copy-by-operator <state> <destination> <attribute> <binding> <action> <prefs>]"

ngsAddToSet() ::= "$::NGS_ADD_TO_SET"
ngsReplaceIfExists() ::= "$::NGS_REPLACE_IF_EXISTS"

ngsDefaultAddPrefs() ::= "="

/*
 * Pure generic TCL templates
 */

proc(name, args, body, public) ::= <<
<if(public)><export(name)><endif>
proc <name> { <args> } {
    <body>
}
>>

namespace(name, block) ::= <<
namespace eval <name> {
    <block>
}
>>

if_(condition, block) ::= <<
if { <condition> } {
    <block>
}
>>

ifElse(condition, trueBlock, falseBlock) ::= <<
if { <condition> } {
    <trueBlock>
} else {
    <falseBlock>
}
>>

foreach(var, list, block) ::= <<
foreach <var> <list> {
    <block>
}
>>

optionalArguments(names) ::= <<
<names:{n|{ <n> ""\}}; separator=" ">
>>

export(name) ::= "namespace export <name>"

toSafeVar(name) ::= "${<name>}"

return(statement) ::= "return <statement>"

set(var, value_) ::= "set <var> <value_>"

list(words) ::= <<
[list <words; separator=" ">]
>>

variable(var, defaultValue) ::= "variable <var> <defaultValue>"

dictCreate(pairs) ::= "[dict create <pairs; separator={ }>]"
