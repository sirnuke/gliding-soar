/*
 * Generic AST->Text templates
 */

bindWrapper(element) ::= <<<\\>
<proc(name=funcBindToPublic(), args="args", public=true, body={<\\>
upvar binding binding
::<commonNamespace()>::<funcBindToInternal()> "<elementToTCL(element)>" $args
})>
>>

setWrapper(element) ::= <<<\\>
<proc(name=funcSetPublic(), args="args", public=true, body={<\\>
::<commonNamespace()>::<funcSetInternal()> "<elementToTCL(element)>" $args
})>
>>

applyWrapper(element) ::= <<<\\>
<proc(name=funcApplyPublic(), args="args", public=true, body={<\\>
::<commonNamespace()>::<funcApplyInternal()> "<elementToTCL(element)>" $args
})>
>>

addToWrapper(element) ::= <<<\\>
<proc(name=funcAddToPublic(), args="args", public=true, body={<\\>
::<commonNamespace()>::<funcAddToInternal()> "<elementToTCL(element)>" $args
})>
>>

removeWrapper(element) ::= <<<\\>
<proc(name=funcRemovePublic(), args="args", public=true, body={<\\>
::<commonNamespace()>::<funcRemoveInternal()> "<elementToTCL(element)>" $args
})>
>>

declareIdentifier(element) ::= "variable identifier <elementToIdentifier(element)>"
declareType(element) ::= "variable type <elementToType(element)>"

namespace(name, block) ::= <<
namespace eval <name> {
    <block>
}
>>

elementToType(element) ::= "<element.identifier.fullyQualified; separator={.}>"
elementToIdentifier(element) ::= "<element.identifier.lowercase>"
elementToTCL(element) ::= "<element.identifier.fullyQualified; separator={::}>"

proc(name, args, body, public) ::= <<
<if(public)>namespace export <name><endif>
proc <name> { <args> } {
    <body>
}
>>

funcBindToPublic() ::= "bind"
funcBindToInternal() ::= "_bind"

funcSetPublic() ::= "set"
funcSetInternal() ::= "_set"

funcApplyPublic() ::= "apply"
funcApplyInternal() ::= "_apply"

funcAddToPublic() ::= "add"
funcAddToInternal() ::= "_add"

funcRemovePublic() ::= "remove"
funcRemoveInternal() ::= "_remove"

commonNamespace() ::= "Glide"

ngsDeclareType(element) ::= "::NGS_DeclareType <elementToType(element)> {}"

/*
requiredParametersAsArguments(members) ::= <<
<members:{m|<if(m.param&&!m.optional)><\\>
<m.identifier.lowercase> <\\>
<endif><\\>
}>
>>

optionalParametersAsArguments(members) ::= <<
<members:{m|<if(m.param&&m.optional)><\\>
<optionalArguments(m.identifier.lowercase)> <\\>
<endif><\\>
}>
>>

memberDefinitionVariable() ::= "members"

funcSetScope() ::= "set-scope"
funcBindTo() ::= "_bind"
funcTest() ::= "_test"
funcCheckLhs() ::= "_check-lhs"
funcCheckRhs() ::= "_check-rhs"
funcCheckTypes() ::= "_check-types"
funcClaimBinding() ::= "_claim-binding"
funcOutputBinding() ::= "output-binding"
funcInputBinding() ::= "input-binding"
funcStateBinding() ::= "state-binding"
funcGoalBinding() ::= "goal-binding"
funcCheckIMod() ::= "_check-i-modification"
funcCheckOMod() ::= "_check-o-modification"
funcCreate() ::= "_create"
funcCreateByOperator() ::= "_create_by_operator"
funcConvertAttrs() ::= "_convert_attrs"

checkRhsElaboration() ::= "<funcCheckRhs()> elaboration"
checkRhsProposal()    ::= "<funcCheckRhs()> proposal"

checkLhs() ::= "<funcCheckLhs()>"

defineMembers(element) ::= <<
<variable(memberDefinitionVariable(), dictCreate(element.allMembers:defineMember()))>
>>

defineMember(member) ::= <<
<member.identifier> <dictCreate({<\\>
support <member.support.label> <\\>
param <member.param> <\\>
optional <member.optional> <\\>
const <member.const> <\\>
tag <member.tag> <\\>
type <member.type> <\\>
multiple <member.multiple><\\>
})>
>>

checkTypes(list) ::= <<
<funcCheckTypes()> <list; separator=" ">
>>
claimBinding(val, type) ::= "<funcClaimBinding()> <val> <type>"

callCreate(type, destination, attribute, binding, attrs) ::= "[::glide::<funcCreate()> <type> <destination> <attribute> <binding> <attrs>]"
callCreateByOperator(type, destination, attribute, binding, state, action, add_prefs, attrs) ::= "[::glide::<funcCreateByOperator()> <type> <destination> <attribute> <binding> <state> <action> <add_prefs> <attrs>]"

checkIModification(destination, attribute, type) ::= "<funcCheckIMod()> <destination> <attribute> <type>"
checkOModification(destination, attribute, type) ::= "<funcCheckOMod()> <destination> <attribute> <type>"

inputBinding() ::= "[::glide::<funcInputBinding()>]"
outputBinding() ::= "[::glide::<funcOutputBinding()>]"
stateBinding() ::= "[::glide::<funcStateBinding()>]"
goalBinding() ::= "[::glide::<funcGoalBinding()>]"

setDefaultValue(varName, defaultValue) ::= <<
<ifElse({$<varName> eq ""},
{set <varName>_ <defaultValue>},
{set <varName>_ $<varName>}
)>
>>

createAttrsOfAllParameters(var, members) ::= <<
<set(var, list({<members:createAttrFromMember(); separator=" ">}))>
>>

createAttrFromMember(member) ::= <<
<if(member.param)><\\>
[list <member.identifier.value> <toSafeVar(member.identifier.value)> <member.type.value>]<\\>
<endif>
>>

scopeVariable() ::= "::glide::_scope"

binding(identifier) ::= "\<<identifier>>"

// TODO: This assumes that we'll never want NGS to create any defaults for us (probably safe?)
ngsDeclareType(type) ::= "::NGS_DeclareType <type> {}"
ngsCreateAttribute(binding, attribute, val) ::= "[ngs-create-attribute <binding> <attribute> <val>]"
ngsCreateTypedObject(destination, attribute, type, binding, attrs) ::= "[ngs-create-typed-object <destination> <attribute> <type> <binding> <attrs>]"
ngsCreateTypedObjectByOperator(state, destination, attribute, type, binding, attrs, action, prefs) ::= "[ngs-create-typed-object-by-operator <state> <destination> <attribute> <type> <binding> <attrs> <action> <prefs>]"
ngsDeepCopy(state, destination, attribute, binding, action, prefs) ::= "[ngs-deep-copy-by-operator <state> <destination> <attribute> <binding> <action> <prefs>]"

ngsAddToSet() ::= "$::NGS_ADD_TO_SET"
ngsReplaceIfExists() ::= "$::NGS_REPLACE_IF_EXISTS"

ngsDefaultAddPrefs() ::= "="


if_(condition, block) ::= <<
if { <condition> } {
    <block>
}
>>

ifElse(condition, trueBlock, falseBlock) ::= <<
if { <condition> } {
    <trueBlock>
} else {
    <falseBlock>
}
>>

foreach(var, list, block) ::= <<
foreach <var> <list> {
    <block>
}
>>

optionalArguments(names) ::= <<
<names:{n|{ <n> ""\}}; separator=" ">
>>

export(name) ::= "namespace export <name>"

toSafeVar(name) ::= "${<name>}"

return(statement) ::= "return <statement>"

set(var, value_) ::= "set <var> <value_>"

list(words) ::= <<
[list <words; separator=" ">]
>>

variable(var, defaultValue) ::= "variable <var> <defaultValue>"

dictCreate(pairs) ::= "[dict create <pairs; separator={ }>]"
*/
